"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const chalk_1 = require("chalk");
const Debug = require("debug");
const split2 = require("split2");
const through2 = require("through2");
const cli_framework_1 = require("@ionic/cli-framework");
const network_1 = require("@ionic/cli-framework/utils/network");
const process_1 = require("@ionic/cli-framework/utils/process");
const errors_1 = require("../../errors");
const serve_1 = require("../../serve");
const DEFAULT_PROGRAM = 'ng';
const NG_SERVE_OPTIONS = [
    {
        name: 'configuration',
        summary: 'Specify the configuration to use.',
        type: String,
        groups: [cli_framework_1.OptionGroup.Advanced],
        hint: chalk_1.default.dim('[ng]'),
    },
];
const debug = Debug('ionic:cli-utils:lib:project:angular:serve');
class AngularServeRunner extends serve_1.ServeRunner {
    constructor(e) {
        super();
        this.e = e;
    }
    getCommandMetadata() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return {
                groups: [cli_framework_1.CommandGroup.Beta],
                description: `
${chalk_1.default.green('ionic serve')} uses the Angular CLI. Use ${chalk_1.default.green('ng serve --help')} to list all Angular CLI options for serving your app. See the ${chalk_1.default.green('ng serve')} docs${chalk_1.default.cyan('[1]')} for explanations. Options not listed below are considered advanced and can be passed to the Angular CLI using the ${chalk_1.default.green('--')} separator after the Ionic CLI arguments. See the examples.

${chalk_1.default.cyan('[1]')}: ${chalk_1.default.bold('https://github.com/angular/angular-cli/wiki/serve')}`,
                options: [
                    {
                        name: 'prod',
                        summary: `Flag to use the ${chalk_1.default.green('production')} configuration`,
                        type: Boolean,
                        hint: chalk_1.default.dim('[ng]'),
                    },
                    {
                        name: 'source-map',
                        summary: 'Output sourcemaps',
                        type: Boolean,
                        groups: [cli_framework_1.OptionGroup.Advanced],
                        hint: chalk_1.default.dim('[ng]'),
                    },
                    ...NG_SERVE_OPTIONS,
                ],
                exampleCommands: [
                    '-- --proxy-config proxy.conf.json',
                ],
            };
        });
    }
    createOptionsFromCommandLine(inputs, options) {
        const baseOptions = super.createOptionsFromCommandLine(inputs, options);
        const prod = options['prod'] ? Boolean(options['prod']) : undefined;
        const configuration = options['configuration'] ? String(options['configuration']) : (prod ? 'production' : undefined);
        const sourcemaps = typeof options['source-map'] === 'boolean' ? Boolean(options['source-map']) : undefined;
        return Object.assign({}, baseOptions, { configuration,
            sourcemaps });
    }
    platformToMode(platform) {
        if (platform === 'ios') {
            return 'ios';
        }
        return 'md';
    }
    modifyOpenURL(url, options) {
        return `${url}${options.browserOption ? options.browserOption : ''}${options.platform ? `?ionic:mode=${this.platformToMode(options.platform)}` : ''}`;
    }
    serveProject(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const [externalIP, availableInterfaces] = yield this.selectExternalIP(options);
            const ngPort = options.port = yield network_1.findClosestOpenPort(options.port, '0.0.0.0');
            const { program } = yield this.serveCommandWrapper(options);
            const interval = setInterval(() => {
                this.e.log.info(`Waiting for connectivity with ${chalk_1.default.green(program)}...`);
            }, 5000);
            yield network_1.isHostConnectable('localhost', ngPort);
            clearInterval(interval);
            return {
                custom: program !== DEFAULT_PROGRAM,
                protocol: 'http',
                localAddress: 'localhost',
                externalAddress: externalIP,
                externalNetworkInterfaces: availableInterfaces,
                port: ngPort,
                externallyAccessible: ![serve_1.BIND_ALL_ADDRESS, ...serve_1.LOCAL_ADDRESSES].includes(externalIP),
            };
        });
    }
    serveCommandWrapper(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.servecmd(options);
            }
            catch (e) {
                if (!(e instanceof errors_1.ServeCommandNotFoundException)) {
                    throw e;
                }
                const pkg = '@angular/cli';
                this.e.log.nl();
                throw new errors_1.FatalException(`${chalk_1.default.green(pkg)} is required for ${chalk_1.default.green('ionic serve')} to work properly.\n` +
                    `Looks like ${chalk_1.default.green(pkg)} isn't installed in this project.\n\n` +
                    `This package is required for ${chalk_1.default.green('ionic serve')}. For more details, please see the CHANGELOG: ${chalk_1.default.bold('https://github.com/ionic-team/ionic-cli/blob/master/packages/ionic/CHANGELOG.md#4.0.0')}`);
            }
        });
    }
    servecmd(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { pkgManagerArgs } = yield Promise.resolve().then(() => require('../../utils/npm'));
            const pkg = yield this.e.project.requirePackageJson();
            let program = DEFAULT_PROGRAM;
            let args = yield this.serveOptionsToNgArgs(options);
            const shellOptions = { cwd: this.e.project.directory };
            debug(`Looking for ${chalk_1.default.cyan(serve_1.SERVE_SCRIPT)} npm script.`);
            if (pkg.scripts && pkg.scripts[serve_1.SERVE_SCRIPT]) {
                debug(`Invoking ${chalk_1.default.cyan(serve_1.SERVE_SCRIPT)} npm script.`);
                const [pkgManager, ...pkgArgs] = yield pkgManagerArgs(this.e.config.get('npmClient'), { command: 'run', script: serve_1.SERVE_SCRIPT, scriptArgs: [...args] });
                program = pkgManager;
                args = pkgArgs;
            }
            else {
                args = [...this.buildArchitectCommand(options), ...args];
            }
            const p = this.e.shell.spawn(program, args, shellOptions);
            this.emit('cli-utility-spawn', p);
            return new Promise((resolve, reject) => {
                p.on('error', (err) => {
                    if (program === DEFAULT_PROGRAM && err.code === 'ENOENT') {
                        reject(new errors_1.ServeCommandNotFoundException(`${chalk_1.default.bold(DEFAULT_PROGRAM)} command not found.`));
                    }
                    else {
                        reject(err);
                    }
                });
                process_1.onBeforeExit(() => tslib_1.__awaiter(this, void 0, void 0, function* () { return p.kill(); }));
                const log = this.e.log.clone();
                log.setFormatter(cli_framework_1.createPrefixedFormatter(chalk_1.default.dim(`[${program}]`)));
                const ws = log.createWriteStream(cli_framework_1.LOGGER_LEVELS.INFO);
                if (program === DEFAULT_PROGRAM) {
                    const stdoutFilter = through2(function (chunk, enc, callback) {
                        const str = chunk.toString();
                        if (!str.includes('Development Server is listening')) {
                            this.push(chunk);
                        }
                        callback();
                    });
                    p.stdout.pipe(split2()).pipe(stdoutFilter).pipe(ws);
                    p.stderr.pipe(split2()).pipe(ws);
                }
                else {
                    p.stdout.pipe(split2()).pipe(ws);
                    p.stderr.pipe(split2()).pipe(ws);
                }
                resolve({ program });
            });
        });
    }
    serveOptionsToNgArgs(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const args = {
                _: [],
                host: options.address,
                port: String(options.port),
                'source-map': options.sourcemaps !== false ? options.sourcemaps : 'false',
            };
            if (options.engine === 'cordova') {
                const integration = yield this.e.project.getIntegration('cordova');
                args.platform = options.platform;
                if (this.e.project.directory !== integration.root) {
                    args.cordovaBasePath = integration.root;
                }
            }
            return [...cli_framework_1.unparseArgs(args), ...options['--']];
        });
    }
    buildArchitectCommand(options) {
        const cmd = options.engine === 'cordova' ? 'ionic-cordova-serve' : 'serve';
        const project = options.project ? options.project : 'app';
        return ['run', `${project}:${cmd}${options.configuration ? `:${options.configuration}` : ''}`];
    }
}
exports.AngularServeRunner = AngularServeRunner;
